#ifndef ACCIDENTS_COLLATOR_H
#define ACCIDENTS_COLLATOR_H

//---------------------------------------------------------------------------
//
// Copyright (c) PC2Lab Development Team
// All rights reserved.
//
// This file is part of free(dom) software -- you can redistribute it
// and/or modify it under the terms of the GNU General Public
// License (GPL)as published by the Free Software Foundation, either
// version 3 (GPL v3), or (at your option) a later version.
//
// The software is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// Miami University and PC2Lab makes no representations or warranties
// about the suitability of the software, either express or implied,
// including but not limited to the implied warranties of
// merchantability, fitness for a particular purpose, or
// non-infringement.  Miami University and PC2Lab is not be liable for
// any damages suffered by licensee as a result of using, result of
// using, modifying or distributing this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of this license.
//
// Authors: Dhananjai M. Rao       raodm@miamiOH.edu
//
//---------------------------------------------------------------------------

#include <ctime>
#include <string>
#include <vector>
#include <unordered_map>
#include "ArgParser.h"

// Forward declarations to streamline code.
class OSMData;

/** A short cut for timestamp structure */
using Timestamp = std::tm;


/**
 * The top-level class for aggregating traffic accidents and collating
 * them based on the nodes in a way.  For each accident, its latitude
 * and longitude values are used to attribute it to the nearest
 * intersection (no more than 1/4 mile).  The results from this
 * program are used by the WayRiskAnalyzer.
 */
class AccidentsCollator {
public:
    /** The top-level method that coordinates the various tasks.
        
        This method essentially calls various internal helper methods
        in the following order:

        <ol>

        <li>First it calls loadModel method which loads the generated
        model with nodes, ways, and bulidings data into memory.</li>
        
        </ol>
    */
    int run(int argc, char *argv[]);

protected:
    /** This is a simple inner class that is used to conveniently
        encapsulate various command-line arguments that is used by the
        model generator.  This encapsulation streamlines managing
        several different command-line arguments in a streamlined
        manner
    */
    class CmdLineArgs {
    public:
        /** The path to the text file from where model data is to be
            loaded. This text file must have been generated by
            ModelGenerator in order to correctly operate with this
            class.  Use the \c --model command-line argument to set
            its value.
        */
        std::string modelFilePath;

        /** Optional output xfig file to which the nodes and accident
            counts are to be written.  Use the \c --xfig command-line
            option to set it.
        */
        std::string xfigFilePath;

        /** The scale for the output XFIG figure so that various
            shapes and information are readable. Use the \c
            --xfig-scale command-line option to set it.
        */
        int figScale = 1638400;

        /**
           The value to be subtracted from xFig x-coordinates
           (i.e. longitude) so that the figure is left-justified.
        */
        int xClip = 6283938;

        /**
           The value to be subtracted from xFig y-coordinates
           (i.e. latitude) so that the figure is top-justified.
        */
        int yClip = 9119994;
        
        /** The maximum distance around a node up to which an accident
            can be assigned.  That is the distance between a node and
            an traffic-accident location should less than this value.
            Use the command-line option \c --max-dist to set it.

            \note This value is in miles.
        */
        double maxDist = 0.25;

        /** The path to the TSV file containing accidents data.  This
            data is read line-by-line and processed to generate the
            accident counts for nodes.  This is specified via the \c
            --accidents-tsv command-line option.
        */
        std::string accidentsFile;

        /** The path to the TSV file to where results are to be written.
            Path to this output file is specified via the \c
            --output-tsv command-line option.
        */
        std::string outputFile;
        
        /** The starting date (inclusive) from where taxi rides in the
            text file are to be processed.  This data is used to
            generate traffic to estimate traffic flowing through a
            given way/node.  This is specified via the \c --start-date
            command-line option.
        */
        std::string startDate = "01/01/2022";
        
        /** The end date (inclusive) from where taxi rides in the
            text file are to be processed.  This data is used to
            generate traffic to estimate traffic flowing through a
            given way/node.  This is specified via the \c --end-date
            command-line option.
        */
        std::string endDate = "12/31/2022";

        /** The number of lines from the accidents file that are
           processed as a big batch.  Bigger batches are generally
           better but take more memory.  This value is set via the
           --batch-size command-line argument.
        */
        int batchSize = 8000;

        /** The path to the shape file from where census tract shapes
            are to be loaded. This is specified via \c --shape */
        std::string shapeFilePath;

        /** The path to the DBF file that contains metadata for the
            census tract shapes. This is specified via the \c --dbf
            command-line option */
        std::string dbfFilePath;
        
    } cmdLineArgs;

protected:
    /** This string contains the full command-line as specified to
        the program. This string is created before any
        command-line arguments are processed.  This is convenient
        for logging purposes.  This not really a command-line 
    */
    std::string fullCmdLine;

    /**
     * This is a simple inner-class that is used to accumulate traffic
     * accident information for each node.
     */
    class AccidentInfo {
    public:
        int count    = 0;
        int injuries = 0;
        int deaths   = 0;
        std::string info;  // anything we need
    };
 
    /**
     * Synonym for unordered_map with key being node.OSMId and the value
     * is an accident class defined further below.
     */
    using AccidentsMap = std::unordered_map<long, AccidentInfo>;
   
private: 
    /** Internal helper method to parse command-line arguments and
        poulate the internal cmdLineArgs object with pertinent
        information.

        This method internally uses the ArgParser to parse out the
        command-line argument specified by the user.

        \param[in] args The number of command-line arguments -- i.e.,
        the size of the argv array.

        \param[in] argv The actual command-line arguments.

        \return This method returns zero if the command-line arguments
        were successfully processed.  On errors it returns a non-zero
        error code.
    */
    int processArgs(int argc, char *argv[]);

    /** Write the accidents information to the given output stream.

        \param[in] accidents The map of accidents to be written to the
        given output stream.

        \param[out] os The output stream to where the data is to be
        written.
     */
    void write(const AccidentsMap& accidents, const OSMData& model,
               std::ostream& os);

    void genXFig(const AccidentsMap& accidents, const OSMData& model);

    /**
       The main method that processes accidents data, finds nearest
       nodes, and collates the accident data.

       \param[in] accidents The data file with accidents to be read
       and processed.

       \param[in] model The OSM model from where nodes are to be used
       for collation.

       \param[out] out The output stream to where the sumnmary
       accidents data is to be written.
    */
    AccidentsMap collate(std::istream& accidents, const OSMData& model,
                         std::ostream& out);
    /**
     * Convenience method to convert a timestamp of the form
     * 12/25/2022 03:45:00 PM to corresponding time structure to ease
     * further processing and comparisons
     */
    Timestamp toTimestamp(const std::string& timestamp) const;

   /**
     * Determine if a given timestamp is at of after given reference
     * timestamp.
     *
     * \param[in] ref The reference timestamp for comparison.
     *
     * \param[in] ts The timestasmp for comparison.
     *
     * \return This method returns true if ts >= ref, while only
     * accounting for month, day, and year (ignoring minute of the day)
     */
    bool isHigher(const Timestamp& ref, const Timestamp& ts) {
        return ((ref.tm_year <= ts.tm_year) && (ref.tm_mon <= ts.tm_mon) &&
                (ref.tm_mday <= ts.tm_mday));
    }

    std::vector<std::string>
    getNextBatch(std::istream& accidentsData, int &lNum,
                 const int batchSize) const;
    
    double logScaleAcc(const double acc, const double minAcc,
                       const double maxAcc) const;    
};

#endif
