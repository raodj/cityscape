#ifndef SCHEDULEGENERATORHELPER_CPP
#define SCHEDULEGENERATORHELPER_CPP
//------------------------------------------------------------
//
// This file is part of HAPLOS <http://pc2lab.cec.miamiOH.edu/>
//
// Human  Population  and   Location  Simulator (HAPLOS)  is
// free software: you can  redistribute it and/or  modify it
// under the terms of the GNU  General Public License  (GPL)
// as published  by  the   Free  Software Foundation, either
// version 3 (GPL v3), or  (at your option) a later version.
//
// HAPLOS is distributed in the hope that it will  be useful,
// but   WITHOUT  ANY  WARRANTY;  without  even  the IMPLIED
// WARRANTY of  MERCHANTABILITY  or FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Miami University and the HAPLOS  development team make no
// representations  or  warranties  about the suitability of
// the software,  either  express  or implied, including but
// not limited to the implied warranties of merchantability,
// fitness  for a  particular  purpose, or non-infringement.
// Miami  University and  its affiliates shall not be liable
// for any damages  suffered by the  licensee as a result of
// using, modifying,  or distributing  this software  or its
// derivatives.
//
// By using or  copying  this  Software,  Licensee  agree to
// abide  by the intellectual  property laws,  and all other
// applicable  laws of  the U.S.,  and the terms of the  GNU
// General  Public  License  (version 3).  You  should  have
// received a  copy of the  GNU General Public License along
// with HAPLOS.  If not, you may  download copies  of GPL V3
// from <http://www.gnu.org/licenses/>.
//
//-----------------------------------------------------------
#include <stdio.h>
#include <vector>
#include <utility>
#include "Family.h"
#include "Buildings/Medical.h"
#include "Buildings/School.h"
#include "Buildings/Business.h"
#include "buildingHelper.pcpp"


struct sort_pair{
    bool operator()(const std::pair<int, int> &left, const std::pair<int, int> &right){
        return left.first < right.first;
    }
    
};

void generateYoungChildSchedule(Person* p, Family *f){
    //Yougn Child (Follow Adult always or day care)
    Schedule *currentSchedule = p->getSchedule();
    Building *home =f->getHome();
    
    
    //Set School Location
    if(currentSchedule->getScheduleType()==1 || currentSchedule->getScheduleType()==2){
        //Set School
        Building *schoolLocation=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'S', -1, p->getAge(), 0);
        if(schoolLocation==NULL){
            std::cout<<"No School Location Found For Young Child"<<std::endl;
        }else{
            currentSchedule->setJobLocation(schoolLocation->getID());
        }
        
        
    }
    
}

void generateYoungSchoolAgedChildSchedule(Person *p, Family *f){
    //Older School Aged Child (On own after school)
    Schedule *currentSchedule = p->getSchedule();
    Building *home =f->getHome();
    
    //Set Probablities for where they can go
    double workProb=0;
    double outProb=0.2;
    double homeProb=0.8;
    int radius = 2;
    
    
    //Set School Location
    if(currentSchedule->getScheduleType()==1 || currentSchedule->getScheduleType()==2){
        //Set School
        Building *schoolLocation=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'S', -1, p->getAge(), 0);
        if(schoolLocation==NULL){
            //std::cout<<"No School Location Found For School Aged Child"<<std::endl;
            //std::cout<<p->toString()<<std::endl;
        }else{
            //std::cout<<"School Found"<<std::endl;
            currentSchedule->setJobLocation(schoolLocation->getID());
        }
        
        
    }
    //std::cout<<"\tGenerating Schedule"<<std::endl;
    //School Aged Child (On own after school)
    std::discrete_distribution<int> distribution{homeProb,workProb,outProb};
    
    School *attendingSchool= static_cast<School* >(allBuildings[currentSchedule->getJobLocation()]);
    attendingSchool->addStudent(0);
    
    int dayEndTime=0;
    int dayTime=0;  //Time for current day (Midnight = 0, 11:59=144
    int trueTime=0; //Actual HAPLOS Time (Monday at Midnight = 0, till Sunday at 11:59 = 1008)
    int totalTimeSpentAtHome=0; //Total Time spent at home for the given day
    
    //Get School start and End times for reference
    int schoolStart = dayTime+attendingSchool->getSchoolStartTime();
    int schoolEnd = dayTime+attendingSchool->getSchoolEndTime();
    
    //Add One Hour for Sleep for Previous Day
    totalTimeSpentAtHome=6;
    int timeUpOnMonday = schoolStart;
    //Create Schedule
    for(int day=0; day< 7 ; day++){
        //Update trueTime to reflect a full day has passed
        trueTime+=dayTime;
        dayTime=0;
        //Kids should Always be home at the start of the day (Curfew at 23:00 (138))
        Building *lastPlace = home;
        if(day<5){
            //School Day
            //Add Sleeping Time if Needed
            
            if(totalTimeSpentAtHome<48){
                int timeNeeded = 48-totalTimeSpentAtHome;
                if(dayTime+timeNeeded<schoolStart){
                    //Progress Time to Earliest Possible Activty time
                    dayTime+=timeNeeded;
                }
            }
            
            if (totalTimeSpentAtHome>=48 && dayTime<schoolStart){
                //Activity before School
                //std::cout<<"\t\tBefore School Activty"<<std::endl;
                switch(distribution(generator)){
                    case 0:
                        //Home
                        break;
                    case 1:
                        //Job (Should not Happen)
                        //std::cout<<"ERROR: KID GOT A JOB"<<std::endl;
                        break;
                    case 2:
                        //Out
                        //std::cout<< "\t\t\tFind Place To Go Out (Before)" <<std::endl;
                        lastPlace=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'H', radius, trueTime+dayTime, trueTime+dayTime+schoolStart);
                        if(lastPlace==NULL){
                            //No avaliable place to go so just return back to home
                            //std::cout<<"\t\tBefore School: No Places found to go out :("<<std::endl;
                            //std::cout<<"\t\t\tTime Frame: "<<trueTime+dayTime<<"-"<<trueTime+dayTime+schoolStart<<std::endl;
                            lastPlace=home;
                        }
                        totalTimeSpentAtHome=0;
                        break;
                }
            }
            
            //std::cout<<"\t\In School"<<std::endl;
            //Advance time to Start of School
            totalTimeSpentAtHome=0;
            dayTime=schoolStart;
            //Go To School
            
            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
            dayTime+=schoolEnd-schoolStart;
            currentSchedule->addTimeSlot(TimeSlot(attendingSchool->getID(), trueTime+dayTime, 'S'));
            
            // std::cout<<"\t\tAfter School Activty"<<std::endl;
            while(dayTime<138){
                //std::cout<<dayTime<<std::endl;
                //Activity After School
                switch(distribution(generator)){
                    case 0:
                        //Home
                        //update time to reflect staying at home once home
                        totalTimeSpentAtHome+= 138 - dayTime;
                        dayTime =138;
                        break;
                    case 1:
                        //Job (Should not Happen)
                        break;
                    case 2:
                        //Out
                        //std::cout<< "\t\t\tFind Place To Go Out (After)" <<std::endl;
                        int timeSpentOut=1;
                        if(138-dayTime){
                            timeSpentOut=(int)rand() % (138-dayTime)+1;
                        }
                        lastPlace=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'V', radius, trueTime+dayTime, trueTime+dayTime+timeSpentOut);
                        if(lastPlace==NULL){
                            //No avaliable place to go so just return back to home
                            //std::cout<<"\t\t After School: No Places found to go out :("<<std::endl;
                            //std::cout<<"\t\t\tTime Frame: "<<trueTime+dayTime<<"-"<<trueTime+dayTime+timeSpentOut<<std::endl;
                            //update time to reflect staying at home once home
                            totalTimeSpentAtHome+= 138 - dayTime;
                            dayTime =138;
                        }else{
                            
                            dayTime+=timeSpentOut;
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, 'V'));
                            lastPlace->addVisitor(trueTime+dayTime,schoolStart);
                        }
                        
                        break;
                }
            }
        }
        else{
            //Weekend
            //Add Sleeping Time if Needed
            if(totalTimeSpentAtHome<48){
                int timeNeeded = 48-totalTimeSpentAtHome;
                //Progress Time to Earliest Possible Activty time
                dayTime+=timeNeeded;
            }
            int curfew = 138;
            int sleepIfOutAllNight = 144-curfew + timeUpOnMonday;
            if(sleepIfOutAllNight<48 && day==6){
                curfew = curfew-(48-sleepIfOutAllNight);
            }
            while(dayTime<curfew){
                int timeSpentOut=1;
                //Activity After School
                switch(distribution(generator)){
                    case 0:
                        //Home
                        //update time to reflect staying at home once home
                        if (lastPlace!=home){
                            //Update Schedule to Reflect Change of Location
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                        }
                        timeSpentOut=(int)rand() % (138-dayTime)+1;
                        totalTimeSpentAtHome+= timeSpentOut;
                        dayTime +=timeSpentOut;
                        break;
                    case 1:
                        //Job (Should not Happen)
                        break;
                    case 2:
                        //Out
                        //std::cout<< "\t\t\tFind Place To Go Out (After)" <<std::endl;
                        timeSpentOut=1;
                        if(138-dayTime>1){
                            timeSpentOut=(int)rand() % (138-dayTime)+1;
                        }
                        
                        //Update Schedule To reflect moving of location
                        currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                        
                        Building *lastPlace_tmp=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'V', radius, trueTime+dayTime, trueTime+dayTime+timeSpentOut);
                        
                        if(lastPlace_tmp==NULL){
                            //No avaliable place to go so just return back to home
                            std::cout<<"\t\t\tNo Places found to go out :(";
                            //update time to reflect staying at home once home
                            totalTimeSpentAtHome+= 138 - dayTime;
                            dayTime =curfew;
                        }else{
                            lastPlace = lastPlace_tmp;
                            lastPlace->addVisitor(trueTime+dayTime,timeSpentOut);
                            dayTime+=timeSpentOut;
                            
                        }
                        
                        break;
                }
                
            }
        }
        totalTimeSpentAtHome+=144-dayTime;
        dayTime=144;
    }
    
}

void generateSchoolAgedChildSchedule(Person *p, Family *f){
    //Older School Aged Child (On own after school)
    Schedule *currentSchedule = p->getSchedule();
    Building *home =f->getHome();
    
    //Set Probablities for where they can go
    double workProb=0;
    double outProb=0.2;
    double homeProb=0.8;
    int radius = 2;
    
    //std::cout<<"\tGenerating Schedule"<<std::endl;
    //School Aged Child (On own after school)
    std::discrete_distribution<int> distribution{homeProb,workProb,outProb};
    
    School *attendingSchool= static_cast<School* >(allBuildings[currentSchedule->getJobLocation()]);
    attendingSchool->addStudent(0);

    int dayEndTime=0;
    int dayTime=0;  //Time for current day (Midnight = 0, 11:59=144
    int trueTime=0; //Actual HAPLOS Time (Monday at Midnight = 0, till Sunday at 11:59 = 1008)
    int totalTimeSpentAtHome=0; //Total Time spent at home for the given day
    
    //Get School start and End times for reference
    int schoolStart = dayTime+attendingSchool->getSchoolStartTime();
    int schoolEnd = dayTime+attendingSchool->getSchoolEndTime();
    
    //Add One Hour for Sleep for Previous Day
    totalTimeSpentAtHome=6;
    int timeUpOnMonday = schoolStart;
    //Create Schedule
    for(int day=0; day< 7 ; day++){
        //Update trueTime to reflect a full day has passed
        trueTime+=dayTime;
        dayTime=0;
        //Kids should Always be home at the start of the day (Curfew at 23:00 (138))
        Building *lastPlace = home;
        if(day<5){
            //School Day
            //Add Sleeping Time if Needed
            
            if(totalTimeSpentAtHome<48){
                int timeNeeded = 48-totalTimeSpentAtHome;
                if(dayTime+timeNeeded<schoolStart){
                    //Progress Time to Earliest Possible Activty time
                    dayTime+=timeNeeded;
                }
            }
                
            if (totalTimeSpentAtHome>=48 && dayTime<schoolStart){
                //Activity before School
               // std::cout<<"\t\tBefore School Activty"<<std::endl;
                switch(distribution(generator)){
                    case 0:
                        //Home
                        break;
                    case 1:
                        //Job (Should not Happen)
                        //std::cout<<"ERROR: KID GOT A JOB"<<std::endl;
                        break;
                    case 2:
                        //Out
                        //std::cout<< "\t\t\tFind Place To Go Out (Before)" <<std::endl;
                        lastPlace=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'H', radius, trueTime+dayTime, trueTime+dayTime+schoolStart);
                        if(lastPlace==NULL){
                            //No avaliable place to go so just return back to home
                            //std::cout<<"\t\tBefore School: No Places found to go out :("<<std::endl;
                            //std::cout<<"\t\t\tTime Frame: "<<trueTime+dayTime<<"-"<<trueTime+dayTime+schoolStart<<std::endl;
                            lastPlace=home;
                        }
                        totalTimeSpentAtHome=0;
                        break;
                }
           }
            
         //std::cout<<"\t\In School"<<std::endl;
            //Advance time to Start of School
            totalTimeSpentAtHome=0;
            dayTime=schoolStart;
            //Go To School
            
            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
            dayTime+=schoolEnd-schoolStart;
            currentSchedule->addTimeSlot(TimeSlot(attendingSchool->getID(), trueTime+dayTime, 'S'));
            
           // std::cout<<"\t\tAfter School Activty"<<std::endl;
            while(dayTime<138){
                //std::cout<<dayTime<<std::endl;
                //Activity After School
                switch(distribution(generator)){
                    case 0:
                        //Home
                        //update time to reflect staying at home once home
                        totalTimeSpentAtHome+= 138 - dayTime;
                        dayTime =138;
                        break;
                    case 1:
                        //Job (Should not Happen)
                        break;
                    case 2:
                        //Out
                        //std::cout<< "\t\t\tFind Place To Go Out (After)" <<std::endl;
                        int timeSpentOut=1;
                        if(138-dayTime){
                            timeSpentOut=(int)rand() % (138-dayTime)+1;
                        }
                        lastPlace=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'V', radius, trueTime+dayTime, trueTime+dayTime+timeSpentOut);
                        if(lastPlace==NULL){
                            //No avaliable place to go so just return back to home
                            //std::cout<<"\t\t After School: No Places found to go out :("<<std::endl;
                            //std::cout<<"\t\t\tTime Frame: "<<trueTime+dayTime<<"-"<<trueTime+dayTime+timeSpentOut<<std::endl;
                            //update time to reflect staying at home once home
                            totalTimeSpentAtHome+= 138 - dayTime;
                            dayTime =138;
                        }else{

                            dayTime+=timeSpentOut;
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, 'V'));
                            lastPlace->addVisitor(trueTime+dayTime,schoolStart);
                        }
                        
                        break;
                }
            }
        }
        else{
            //Weekend
            //Add Sleeping Time if Needed
            if(totalTimeSpentAtHome<48){
                int timeNeeded = 48-totalTimeSpentAtHome;
                //Progress Time to Earliest Possible Activty time
                dayTime+=timeNeeded;
            }
            int curfew = 138;
            int sleepIfOutAllNight = 144-curfew + timeUpOnMonday;
            if(sleepIfOutAllNight<48 && day==6){
                curfew = curfew-(48-sleepIfOutAllNight);
            }
            while(dayTime<curfew){
                int timeSpentOut=1;
                //Activity After School
                switch(distribution(generator)){
                    case 0:
                        //Home
                        //update time to reflect staying at home once home
                        if (lastPlace!=home){
                            //Update Schedule to Reflect Change of Location
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                        }
                        timeSpentOut=(int)rand() % (138-dayTime)+1;
                        totalTimeSpentAtHome+= timeSpentOut;
                        dayTime +=timeSpentOut;
                        break;
                    case 1:
                        //Job (Should not Happen)
                        break;
                    case 2:
                        //Out
                        //std::cout<< "\t\t\tFind Place To Go Out (After)" <<std::endl;
                        timeSpentOut=1;
                        if(138-dayTime>1){
                            timeSpentOut=(int)rand() % (138-dayTime)+1;
                        }
                        
                        //Update Schedule To reflect moving of location
                        currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));

                        lastPlace=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'V', radius, trueTime+dayTime, trueTime+dayTime+timeSpentOut);

                        if(lastPlace==NULL){
                            //No avaliable place to go so just return back to home
                            std::cout<<"\t\t\tNo Places found to go out :(";
                            //update time to reflect staying at home once home
                            totalTimeSpentAtHome+= 138 - dayTime;
                            dayTime =curfew;
                        }else{
                            lastPlace->addVisitor(trueTime+dayTime,timeSpentOut);
                            dayTime+=timeSpentOut;

                        }
                        
                        break;
                }

            }
        }
        totalTimeSpentAtHome+=144-dayTime;
        dayTime=144;
    }
    
}

bool sort_schoolTimes(const std::pair<int, School*>& firstElem, const std::pair<int, School*>& secondElem) {
    return firstElem.first < secondElem.first;
    
}

void generateEmployeedAdultSchedule(Person *p, Family *f){
    //Working Adult
    Schedule *currentSchedule = p->getSchedule();
    Building *home =f->getHome();
    Building *lastPlace = home;
    Building *jobLocation=allBuildings[currentSchedule->getJobLocation()];
    
    double workProb=0.50;
    double outProb=0.20;
    double homeProb=0.30;
    
    std::discrete_distribution<int> distribution{homeProb,workProb,outProb};
    std::discrete_distribution<int> no_work_left_distribution{0.5,0,0.5};

    //Generate a schedule for everyone else
    int dayTime=0;  //Time for current day (Midnight = 0, 11:59=144
    int trueTime=0; //Actual HAPLOS Time (Sunday at Midnight = 0, till Saturday at 11:59 = 1008)
    int totalTimeSpentAtHome=0; //Total Time spent at home for the given day
    int totalTimeSpentAway = 0; //Once it hits 16 hours (96) force go home
    int dailyTotalTimeAtJob = 0; //Total time spent at job in a given day (0-14 Hours, 0-84 HAPLOS Time)
    int totalTimeSpentAtJob = ((int)rand() % 300)+60; //Total time Spent at work during the week 10-60 hours (60-360)
    //std::cout<<totalTimeSpentAtJob<<std::endl;
    std::vector <std::pair<int, School*> >schoolTimes;
    
    //Get Children School Start Times If Needed
    if(f->getHasChild() && f->getNonWorkingAdult()== NULL){
        for(int fm=0; fm<f->getNumberOfPeople(); fm++){
            Person *p1 = f->getPerson(fm);
            Schedule *sc = p1->getSchedule();
            if(sc->getScheduleType()==1){
                School *attendingSchool= static_cast<School* >(allBuildings[sc->getJobLocation()]);
                
                schoolTimes.push_back(std::make_pair(attendingSchool->getSchoolStartTime(), attendingSchool));
                schoolTimes.push_back(std::make_pair(attendingSchool->getSchoolEndTime(), attendingSchool));
            }
        }
        std::sort(schoolTimes.begin(), schoolTimes.end(), sort_schoolTimes);
    }
    for(int day=0; day< 7 ; day++){
        int currentPlaceInSchoolTimes = 0;
        std::pair<int, School*> nextSchoolTime=std::make_pair(145,nullptr);
        
        //Reset School Time to first one if a week day.
        if(schoolTimes.size()>0 && day<5){
            nextSchoolTime=schoolTimes.at(currentPlaceInSchoolTimes);
        }
        
        //Determine how long needs to be spent at Job today
        if(totalTimeSpentAtJob<(84-schoolTimes.size())){
            //Less than 14 hours needed
            dailyTotalTimeAtJob=(int)rand() % ((84-schoolTimes.size())-totalTimeSpentAtJob);
        }else{
            //More than 14 hours needed
            dailyTotalTimeAtJob=(int)rand() % ((84-schoolTimes.size())-dailyTotalTimeAtJob);
        }
        char visitorType;
        
        while(dayTime<144){
            //Repeat until day is over
            
            //Determine Visitor Type for Last Place
            if(lastPlace==home){
                visitorType='H';
            }else{
                if(lastPlace==jobLocation){
                    visitorType='E';
                }else{
                    visitorType='V';
                }
            }
            
            //Check if child needs to go to School or Be taken to a Neighboor
            if(dayTime>=nextSchoolTime.first-1 && nextSchoolTime.second!=nullptr){
                //Get From School
                currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, 'T'));
                if(currentPlaceInSchoolTimes<schoolTimes.size()-1){
                    //Advance to the next school time
                    currentPlaceInSchoolTimes++;
                    nextSchoolTime=schoolTimes.at(currentPlaceInSchoolTimes);
                    lastPlace=nextSchoolTime.second;
                    totalTimeSpentAway++;
                    dayTime++;
                }else{
                    //No more School times to take into account until the next day
                    nextSchoolTime=std::make_pair(145,nullptr);
                }
            }else{
                //Child does not need to go to school right now
                if(totalTimeSpentAway>=96){
                    //Been out too Long Need to Get Sleep
                    currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                    lastPlace=home;
                    if(nextSchoolTime.first-1>dayTime+48){
                        totalTimeSpentAtHome+= 48;
                        dayTime +=48;
                        totalTimeSpentAway=0;
                    }else{
                        totalTimeSpentAtHome+=nextSchoolTime.first-1-dayTime;
                        dayTime+=nextSchoolTime.first-1;
                    }
                    
                }else{
                    //Can do something else
                    int timeSpentOut=0;
                    int activity=0; //Activity Type
                    
                    //Determine which Distribution to use
                    if(dailyTotalTimeAtJob<=0){
                        //No work Left to do at job
                        activity = no_work_left_distribution(generator);
                    }else{
                        //Work still to do at job
                        activity = distribution(generator);
                    }
                    
                    //Pick Activity
                    switch(activity){
                        case 0:{
                            //Home
                            //update time to reflect staying at home once home
                            if (lastPlace!=home){
                                //Update Schedule to Reflect Change of Location
                                currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, visitorType));
                                lastPlace=home;
                            }
                            timeSpentOut=(int)rand() % ((nextSchoolTime.first-1)-dayTime)+1;
                            totalTimeSpentAtHome+= timeSpentOut;
                            dayTime +=timeSpentOut;
                            break;
                        }
                        case 1:{
                            //Job
                            /*if(f->hasYoungChild()){
                                //Modification to take child to daycare if not already
                            }*/
                            int timeSpentAtJob=0;
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, visitorType));
                            if(dayTime+dailyTotalTimeAtJob>nextSchoolTime.first-1){
                                //Need to take break to pick up child from school
                                timeSpentAtJob =(nextSchoolTime.first-1)-dayTime;
                                
                            }
                            totalTimeSpentAway+=timeSpentAtJob;
                            totalTimeSpentAtJob-=timeSpentAtJob;
                            dailyTotalTimeAtJob-=timeSpentAtJob;
                            dayTime=nextSchoolTime.first-1;
                
                            break;
                        }
                        case 2:{
                            //Out
                            timeSpentOut=1;
                            // if(138-dayTime>1){
                            timeSpentOut=(int)rand() % ((nextSchoolTime.first-1)-dayTime)+1;
                            //}
                            
                            //Update Schedule To reflect moving of location
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, visitorType));
                            Building *lastPlace_tmp=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'V', -1, trueTime+dayTime, trueTime+dayTime+timeSpentOut);
                            
                            if(lastPlace_tmp==NULL){
                                //No avaliable place to go so just return back to home
                                std::cout<<"\t\t\tNo Places found to go out :("<<std::endl;
                                //update time to reflect staying at home once home
                                totalTimeSpentAtHome+= (nextSchoolTime.first-1) - dayTime;
                                dayTime =(nextSchoolTime.first-1);
                            }else{
                                lastPlace=lastPlace_tmp;
                                lastPlace->addVisitor(trueTime+dayTime,timeSpentOut);
                                dayTime+=timeSpentOut;
                                if(totalTimeSpentAtHome<48){
                                    totalTimeSpentAway+=totalTimeSpentAtHome;
                                    totalTimeSpentAtHome=0;
                                }
                                totalTimeSpentAway+=timeSpentOut;
                                
                            }
                            
                            
                            break;
                        }
                    }
                } //End of If
            }//End of School Time If
        }//End of While
        
        //End of Day (Update True Time)
        trueTime+=dayTime;
        if(dayTime>144){
            //Day Bleed Over to Next Day
            if(schoolTimes.size()>0){
                //Make sure bleed over doesn't go past first school time for kids
                if(dayTime-144>schoolTimes.at(currentPlaceInSchoolTimes).first-1){
                    dayTime = schoolTimes.at(currentPlaceInSchoolTimes).first;
                }else{
                    dayTime=dayTime-144;
                }
            }else{
                dayTime=dayTime-144;
            }
        }else{
            //Day Didn't bleed Over
            dayTime=0;
        }
        
    }
    
}


void generateUnemployeedAdultSchedule(Person *p, Family *f){
    //Non-working Adult
    Schedule *currentSchedule = p->getSchedule();
    Building *home =f->getHome();
    Building *lastPlace = home;

    double workProb=0;
    double outProb=0.5;
    double homeProb=0.5;
    
    std::discrete_distribution<int> distribution{homeProb,workProb,outProb};
    
    //Generate a schedule for everyone else
    int dayTime=0;  //Time for current day (Midnight = 0, 11:59=144
    int trueTime=0; //Actual HAPLOS Time (Sunday at Midnight = 0, till Saturday at 11:59 = 1008)
    int totalTimeSpentAtHome=0; //Total Time spent at home for the given day
    int totalTimeSpentAway = 0; //Once it hits 16 hours (96) force go home
    std::vector <std::pair<int, School*> >schoolTimes;
    
    if(f->getHasChild() && f->getNonWorkingAdult()== p){
        for(int fm=0; fm<f->getNumberOfPeople(); fm++){
            Person *p1 = f->getPerson(fm);
            Schedule *sc = p1->getSchedule();
            if(sc->getScheduleType()==1){
                School *attendingSchool= static_cast<School* >(allBuildings[sc->getJobLocation()]);
                
                schoolTimes.push_back(std::make_pair(attendingSchool->getSchoolStartTime(), attendingSchool));
                schoolTimes.push_back(std::make_pair(attendingSchool->getSchoolEndTime(), attendingSchool));
            }
        }
        std::sort(schoolTimes.begin(), schoolTimes.end(), sort_schoolTimes);
    }
    for(int day=0; day< 7 ; day++){
        int currentPlaceInSchoolTimes = 0;
        std::pair<int, School*> nextSchoolTime=std::make_pair(145,nullptr);
        if(schoolTimes.size()>0 && day<5){
            nextSchoolTime=schoolTimes.at(currentPlaceInSchoolTimes);
        }
        while(dayTime<144){
            if(dayTime>=nextSchoolTime.first-1 && nextSchoolTime.second!=nullptr){
                currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, 'T'));
                 if(currentPlaceInSchoolTimes<schoolTimes.size()-1){
                     currentPlaceInSchoolTimes++;
                     nextSchoolTime=schoolTimes.at(currentPlaceInSchoolTimes);
                     lastPlace=nextSchoolTime.second;
                     dayTime++;
                 }else{
                     nextSchoolTime=std::make_pair(145,nullptr);
                 }
            }else{
                if(totalTimeSpentAway>=96){
                    //Been out too Long Need to Get Sleep
                    currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                    lastPlace=home;
                    if(nextSchoolTime.first-1>dayTime+48){
                        totalTimeSpentAtHome+= 48;
                        dayTime +=48;
                        totalTimeSpentAway=0;
                    }else{
                        totalTimeSpentAtHome+=nextSchoolTime.first-1-dayTime;
                        dayTime+=nextSchoolTime.first-1-dayTime;
                    }

                }else{
                    int timeSpentOut=0;
                    //Can go out
                    switch(distribution(generator)){
                        case 0:
                            //Home
                            //update time to reflect staying at home once home
                            if (lastPlace!=home){
                                //Update Schedule to Reflect Change of Location
                                currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                                lastPlace=home;
                            }
                            timeSpentOut=(int)rand() % ((nextSchoolTime.first-1)-dayTime)+1;
                            totalTimeSpentAtHome+= timeSpentOut;
                            dayTime +=timeSpentOut;
                            break;
                        case 1:
                            //Job (Should not Happen)
                            break;
                        case 2:
                            //Out
                            timeSpentOut=1;
                           // if(138-dayTime>1){
                                timeSpentOut=(int)rand() % ((nextSchoolTime.first-1)-dayTime)+1;
                            //}
                            
                            //Update Schedule To reflect moving of location
                            currentSchedule->addTimeSlot(TimeSlot(lastPlace->getID(), trueTime+dayTime, ((lastPlace == home) ? 'H' : 'V')));
                            Building *lastPlace_tmp=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'V', -1, trueTime+dayTime, trueTime+dayTime+timeSpentOut);
                            
                            if(lastPlace_tmp==NULL){
                                //No avaliable place to go so just return back to home
                                std::cout<<"\t\t\tNo Places found to go out :("<<std::endl;
                                //update time to reflect staying at home once home
                                totalTimeSpentAtHome+= (nextSchoolTime.first-1) - dayTime;
                                dayTime =(nextSchoolTime.first-1);
                            }else{
                                lastPlace=lastPlace_tmp;
                                lastPlace->addVisitor(trueTime+dayTime,timeSpentOut);
                                dayTime+=timeSpentOut;
                                if(totalTimeSpentAtHome<48){
                                    totalTimeSpentAway+=totalTimeSpentAtHome;
                                    totalTimeSpentAtHome=0;
                                }
                                totalTimeSpentAway+=timeSpentOut;
                                
                            }
                            
                            
                            break;
                    }
                } //End of If
            }//End of School Time If
        }//End of While
        
        //End of Day (Update True Time)
        trueTime+=dayTime;
        if(dayTime>144){
            //Day Bleed Over to Next Day
            if(schoolTimes.size()>0){
                //Make sure bleed over doesn't go past first school time for kids
                if(dayTime-144>schoolTimes.at(currentPlaceInSchoolTimes).first-1){
                    dayTime = schoolTimes.at(currentPlaceInSchoolTimes).first;
                }else{
                    dayTime=dayTime-144;
                }
            }else{
                dayTime=dayTime-144;
            }
        }else{
            //Day Didn't bleed Over
            dayTime=0;
        }

    }

}

void assignJobSchoolLocations(Family *f){
    Building *home =f->getHome();
    for(int p=0; p<f->getNumberOfPeople(); p++){
        Schedule *currentSchedule =f->getPerson(p)->getSchedule();
        if(currentSchedule->getScheduleType()==1 || currentSchedule->getScheduleType()==2){
            //Set School
            Building *schoolLocation=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'S', -1, f->getPerson(p)->getAge(), 0);
            if(schoolLocation==NULL){
                //std::cout<<"No School Location Found For School Aged Child"<<std::endl;
                //std::cout<<p->toString()<<std::endl;
            }else{
                //std::cout<<"School Found"<<std::endl;
                currentSchedule->setJobLocation(schoolLocation->getID());
            }
            
        }
        
        if(currentSchedule->getScheduleType()==3){
            //Employeed
            //std::cout<<"Loc: "<<home->getLocation()[0]<<","<<home->getLocation()[1]<<std::endl;
            Building *workLocation=findAvaliableBuilding(home->getLocation()[0], home->getLocation()[1], 'E', -1,  0, 0);
            if(workLocation==NULL){
                std::cout<<"No Work Location Found"<<std::endl;
            }else{
                currentSchedule->setJobLocation(workLocation->getID());
            }
            
        }

    }
    
    
}


void generateSchedules(Population &pop) {
    //Creating Schedules for Families
    float oldRatio=0;
    std::cout << "Generating Schedules for Population" << std::endl;
    if(progressDisplay){
        printf("Percentage Complete: %3d%%", 0 );
    }
    fflush(stdout);
    for ( int i =0; i<pop.getNumberOfFamilies(); i++ ) {
        Family *currentFamily = pop.getFamily(i);
        assignJobSchoolLocations(currentFamily);

        for(int p=0; p<currentFamily->getNumberOfPeople(); p++){
            Person *p1 = currentFamily->getPerson(p);
            Schedule *currentSchedule = p1->getSchedule();
            switch(currentSchedule->getScheduleType()){
                case 0:
                    //std::cout<<"Generating Young Child Schedule"<<std::endl;
                    generateYoungChildSchedule(p1, currentFamily);
                    break;
                case 1:
                    //std::cout<<"Generating Young School Aged Child Schedule"<<std::endl;
                    generateYoungSchoolAgedChildSchedule(p1, currentFamily);
                    break;
                case 2:
                    //std::cout<<"Generating School Aged Child Schedule"<<std::endl;
                    generateSchoolAgedChildSchedule(p1, currentFamily);
                    break;
                case 3:
                    //std::cout<<"Generating Employeed Adult Schedule"<<std::endl;
                    generateEmployeedAdultSchedule(p1, currentFamily);
                    break;
                case 4:
                    //std::cout<<"Generating UnEmployeed Schedule"<<std::endl;
                    generateUnemployeedAdultSchedule(p1, currentFamily);
                    break;
                default:
                    std::cout<<"ERROR: Unknown Schedule Type"<<std::endl;
                    break;
            }
            
            
        } //End of Person Loop
        
        
        //Calculate Percent Complete
        if(progressDisplay){
            float ratio = i/(float)pop.getNumberOfFamilies();
            if ( 100*(ratio-oldRatio) > 1 ) {
                //Update Percent Complete Only if there is a Change
                printf("\r");
                printf("Percentage Complete: %3d%%", (int)(ratio*100) );
                oldRatio=ratio;
                fflush(stdout);
            }
        }
    } //End of Family Loop
    //Print out 100% Complete
    if(progressDisplay){
        printf("\r");
        printf("Percentage Complete: %3d%%", 100 );
        fflush(stdout);
    }
    std::cout << std::endl <<"Population Successfully Assigned Locations" << std::endl;
    
}

#endif